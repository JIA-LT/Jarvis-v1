# Jarvis 企业级 AI 平台 - 指标体系设计文档

## 1. 概述

### 1.1 文档目的

本文档描述 Jarvis 企业级 AI 平台的指标体系设计，包括性能指标、业务指标、成本指标、质量指标等，为系统监控、告警、优化提供数据支撑。

### 1.2 设计目标

1. **全面性**：覆盖性能、业务、成本、质量各个维度
2. **实时性**：指标实时采集和更新
3. **准确性**：指标数据准确可靠
4. **可观测性**：支持 Prometheus、Grafana 等工具
5. **可扩展性**：支持自定义指标

---

## 2. 性能指标

### 2.1 QPS（每秒查询数）

#### 2.1.1 指标定义

**总 QPS**：
```python
from prometheus_client import Counter

request_counter = Counter(
    'http_requests_total',
    'Total HTTP requests',
    ['method', 'endpoint', 'status_code']
)

# 记录请求
request_counter.labels(
    method='POST',
    endpoint='/api/v1/chat',
    status_code='200'
).inc()
```

**接口 QPS**：
```python
qps_gauge = Gauge(
    'api_qps',
    'API QPS',
    ['endpoint']
)

# 计算 QPS（每秒更新）
def update_qps():
    for endpoint in endpoints:
        count = get_request_count(endpoint, window=1)
        qps_gauge.labels(endpoint=endpoint).set(count)
```

**租户 QPS**：
```python
tenant_qps_gauge = Gauge(
    'tenant_qps',
    'Tenant QPS',
    ['tenant_id']
)
```

#### 2.1.2 指标采集

**Prometheus 采集配置**：
```yaml
scrape_configs:
  - job_name: 'jarvis-api'
    scrape_interval: 15s
    metrics_path: '/metrics'
    static_configs:
      - targets: ['api:8000']
```

### 2.2 延迟指标

#### 2.2.1 P50/P95/P99 延迟

**实现**：
```python
from prometheus_client import Histogram

latency_histogram = Histogram(
    'http_request_duration_seconds',
    'HTTP request duration',
    ['method', 'endpoint'],
    buckets=[0.1, 0.5, 1.0, 2.0, 5.0, 10.0]
)

# 记录延迟
with latency_histogram.labels(method='POST', endpoint='/api/v1/chat').time():
    result = await process_request()
```

**计算分位数**：
```python
def calculate_percentiles(histogram_data, percentiles=[50, 95, 99]):
    """计算分位数"""
    sorted_data = sorted(histogram_data)
    results = {}
    
    for p in percentiles:
        index = int(len(sorted_data) * p / 100)
        results[f"p{p}"] = sorted_data[index] if index < len(sorted_data) else sorted_data[-1]
    
    return results
```

#### 2.2.2 平均延迟

**实现**：
```python
latency_summary = Summary(
    'http_request_duration_seconds_summary',
    'HTTP request duration summary',
    ['method', 'endpoint']
)

# 记录延迟
latency_summary.labels(method='POST', endpoint='/api/v1/chat').observe(latency)
```

### 2.3 SLA 指标

#### 2.3.1 可用性

**计算方式**：
```
可用性 = (总时间 - 故障时间) / 总时间 * 100%
```

**目标**：
- **99.9%**：月度故障时间 < 43.2 分钟
- **99.99%**：月度故障时间 < 4.32 分钟
- **99.999%**：月度故障时间 < 26 秒

#### 2.3.2 成功率

**实现**：
```python
success_rate_gauge = Gauge(
    'api_success_rate',
    'API success rate',
    ['endpoint']
)

def update_success_rate(endpoint: str):
    """更新成功率"""
    total = get_total_requests(endpoint)
    success = get_success_requests(endpoint)
    rate = success / total if total > 0 else 0
    success_rate_gauge.labels(endpoint=endpoint).set(rate)
```

#### 2.3.3 错误率

**实现**：
```python
error_rate_gauge = Gauge(
    'api_error_rate',
    'API error rate',
    ['endpoint', 'error_type']
)

def update_error_rate(endpoint: str):
    """更新错误率"""
    total = get_total_requests(endpoint)
    errors = get_error_requests(endpoint)
    rate = errors / total if total > 0 else 0
    error_rate_gauge.labels(endpoint=endpoint).set(rate)
```

---

## 3. 业务指标

### 3.1 命中率

#### 3.1.1 缓存命中率

**实现**：
```python
cache_hit_counter = Counter(
    'cache_hits_total',
    'Total cache hits',
    ['cache_level', 'cache_key']
)

cache_miss_counter = Counter(
    'cache_misses_total',
    'Total cache misses',
    ['cache_level', 'cache_key']
)

def calculate_cache_hit_rate(cache_level: str, cache_key: str) -> float:
    """计算缓存命中率"""
    hits = cache_hit_counter.labels(cache_level=cache_level, cache_key=cache_key)._value.get()
    misses = cache_miss_counter.labels(cache_level=cache_level, cache_key=cache_key)._value.get()
    total = hits + misses
    return hits / total if total > 0 else 0
```

#### 3.1.2 检索命中率

**实现**：
```python
retrieval_hit_counter = Counter(
    'retrieval_hits_total',
    'Total retrieval hits',
    ['retrieval_type']
)

retrieval_miss_counter = Counter(
    'retrieval_misses_total',
    'Total retrieval misses',
    ['retrieval_type']
)

def calculate_retrieval_hit_rate(retrieval_type: str) -> float:
    """计算检索命中率"""
    hits = retrieval_hit_counter.labels(retrieval_type=retrieval_type)._value.get()
    misses = retrieval_miss_counter.labels(retrieval_type=retrieval_type)._value.get()
    total = hits + misses
    return hits / total if total > 0 else 0
```

#### 3.1.3 Rerank 提升率

**实现**：
```python
rerank_improvement_gauge = Gauge(
    'rerank_improvement_rate',
    'Rerank improvement rate',
    ['query_type']
)

def calculate_rerank_improvement(query_type: str) -> float:
    """计算 Rerank 提升率"""
    before_rerank_accuracy = get_accuracy_before_rerank(query_type)
    after_rerank_accuracy = get_accuracy_after_rerank(query_type)
    improvement = (after_rerank_accuracy - before_rerank_accuracy) / before_rerank_accuracy
    rerank_improvement_gauge.labels(query_type=query_type).set(improvement)
    return improvement
```

### 3.2 错误率

#### 3.2.1 4xx 错误率

**实现**：
```python
client_error_counter = Counter(
    'http_client_errors_total',
    'Total 4xx errors',
    ['endpoint', 'status_code']
)

def calculate_client_error_rate(endpoint: str) -> float:
    """计算 4xx 错误率"""
    errors = client_error_counter.labels(endpoint=endpoint)._value.get()
    total = get_total_requests(endpoint)
    return errors / total if total > 0 else 0
```

#### 3.2.2 5xx 错误率

**实现**：
```python
server_error_counter = Counter(
    'http_server_errors_total',
    'Total 5xx errors',
    ['endpoint', 'status_code']
)

def calculate_server_error_rate(endpoint: str) -> float:
    """计算 5xx 错误率"""
    errors = server_error_counter.labels(endpoint=endpoint)._value.get()
    total = get_total_requests(endpoint)
    return errors / total if total > 0 else 0
```

#### 3.2.3 超时率

**实现**：
```python
timeout_counter = Counter(
    'request_timeouts_total',
    'Total request timeouts',
    ['endpoint']
)

def calculate_timeout_rate(endpoint: str) -> float:
    """计算超时率"""
    timeouts = timeout_counter.labels(endpoint=endpoint)._value.get()
    total = get_total_requests(endpoint)
    return timeouts / total if total > 0 else 0
```

---

## 4. 成本指标

### 4.1 Token 成本

#### 4.1.1 总 Token 消耗

**实现**：
```python
token_usage_counter = Counter(
    'token_usage_total',
    'Total token usage',
    ['model', 'tenant_id', 'type']  # type: input/output
)

def record_token_usage(model: str, tenant_id: str, input_tokens: int, output_tokens: int):
    """记录 Token 使用"""
    token_usage_counter.labels(model=model, tenant_id=tenant_id, type='input').inc(input_tokens)
    token_usage_counter.labels(model=model, tenant_id=tenant_id, type='output').inc(output_tokens)
```

#### 4.1.2 人均 Token

**实现**：
```python
def calculate_avg_tokens_per_user(tenant_id: str, period: str = 'daily') -> float:
    """计算人均 Token"""
    total_tokens = get_total_tokens(tenant_id, period)
    active_users = get_active_users(tenant_id, period)
    return total_tokens / active_users if active_users > 0 else 0
```

#### 4.1.3 Token 成本

**实现**：
```python
token_cost_gauge = Gauge(
    'token_cost_total',
    'Total token cost',
    ['model', 'tenant_id', 'period']
)

def calculate_token_cost(model: str, tenant_id: str, period: str = 'daily'):
    """计算 Token 成本"""
    input_tokens = get_input_tokens(model, tenant_id, period)
    output_tokens = get_output_tokens(model, tenant_id, period)
    
    input_cost = input_tokens * get_model_input_cost(model)
    output_cost = output_tokens * get_model_output_cost(model)
    total_cost = input_cost + output_cost
    
    token_cost_gauge.labels(model=model, tenant_id=tenant_id, period=period).set(total_cost)
    return total_cost
```

### 4.2 资源成本

#### 4.2.1 计算成本

**实现**：
```python
compute_cost_gauge = Gauge(
    'compute_cost_total',
    'Total compute cost',
    ['resource_type', 'tenant_id']
)

def calculate_compute_cost(resource_type: str, tenant_id: str):
    """计算计算成本"""
    usage_hours = get_resource_usage_hours(resource_type, tenant_id)
    hourly_rate = get_resource_hourly_rate(resource_type)
    cost = usage_hours * hourly_rate
    
    compute_cost_gauge.labels(resource_type=resource_type, tenant_id=tenant_id).set(cost)
    return cost
```

#### 4.2.2 存储成本

**实现**：
```python
storage_cost_gauge = Gauge(
    'storage_cost_total',
    'Total storage cost',
    ['storage_type', 'tenant_id']
)

def calculate_storage_cost(storage_type: str, tenant_id: str):
    """计算存储成本"""
    storage_gb = get_storage_usage_gb(storage_type, tenant_id)
    gb_monthly_rate = get_storage_gb_monthly_rate(storage_type)
    cost = storage_gb * gb_monthly_rate
    
    storage_cost_gauge.labels(storage_type=storage_type, tenant_id=tenant_id).set(cost)
    return cost
```

#### 4.2.3 网络成本

**实现**：
```python
network_cost_gauge = Gauge(
    'network_cost_total',
    'Total network cost',
    ['tenant_id']
)

def calculate_network_cost(tenant_id: str):
    """计算网络成本"""
    data_transfer_gb = get_data_transfer_gb(tenant_id)
    gb_rate = get_data_transfer_gb_rate()
    cost = data_transfer_gb * gb_rate
    
    network_cost_gauge.labels(tenant_id=tenant_id).set(cost)
    return cost
```

---

## 5. 质量指标

### 5.1 回答质量

#### 5.1.1 相关性评分

**实现**：
```python
relevance_score_gauge = Gauge(
    'answer_relevance_score',
    'Answer relevance score',
    ['query_type']
)

def record_relevance_score(query_type: str, score: float):
    """记录相关性评分"""
    relevance_score_gauge.labels(query_type=query_type).set(score)
```

#### 5.1.2 准确性

**实现**：
```python
accuracy_gauge = Gauge(
    'answer_accuracy',
    'Answer accuracy',
    ['evaluation_method']  # human/evaluation_model
)

def calculate_accuracy(evaluation_method: str) -> float:
    """计算准确性"""
    correct = get_correct_answers(evaluation_method)
    total = get_total_answers(evaluation_method)
    accuracy = correct / total if total > 0 else 0
    
    accuracy_gauge.labels(evaluation_method=evaluation_method).set(accuracy)
    return accuracy
```

#### 5.1.3 完整性

**实现**：
```python
completeness_gauge = Gauge(
    'answer_completeness',
    'Answer completeness',
    ['query_type']
)

def calculate_completeness(query_type: str) -> float:
    """计算完整性"""
    complete_answers = get_complete_answers(query_type)
    total_answers = get_total_answers(query_type)
    completeness = complete_answers / total_answers if total_answers > 0 else 0
    
    completeness_gauge.labels(query_type=query_type).set(completeness)
    return completeness
```

### 5.2 检索质量

#### 5.2.1 召回率（Recall）

**实现**：
```python
recall_gauge = Gauge(
    'retrieval_recall',
    'Retrieval recall',
    ['retrieval_method']
)

def calculate_recall(retrieval_method: str) -> float:
    """计算召回率"""
    relevant_retrieved = get_relevant_retrieved(retrieval_method)
    total_relevant = get_total_relevant()
    recall = relevant_retrieved / total_relevant if total_relevant > 0 else 0
    
    recall_gauge.labels(retrieval_method=retrieval_method).set(recall)
    return recall
```

#### 5.2.2 精确率（Precision）

**实现**：
```python
precision_gauge = Gauge(
    'retrieval_precision',
    'Retrieval precision',
    ['retrieval_method']
)

def calculate_precision(retrieval_method: str) -> float:
    """计算精确率"""
    relevant_retrieved = get_relevant_retrieved(retrieval_method)
    total_retrieved = get_total_retrieved(retrieval_method)
    precision = relevant_retrieved / total_retrieved if total_retrieved > 0 else 0
    
    precision_gauge.labels(retrieval_method=retrieval_method).set(precision)
    return precision
```

#### 5.2.3 NDCG（归一化折损累积增益）

**实现**：
```python
ndcg_gauge = Gauge(
    'retrieval_ndcg',
    'Retrieval NDCG',
    ['retrieval_method', 'k']  # k: Top-K
)

def calculate_ndcg(retrieval_method: str, k: int = 10) -> float:
    """计算 NDCG"""
    import numpy as np
    
    # 获取检索结果的相关性分数
    relevance_scores = get_relevance_scores(retrieval_method, k)
    
    # 计算 DCG
    dcg = sum(score / np.log2(i + 2) for i, score in enumerate(relevance_scores))
    
    # 计算理想 DCG（IDCG）
    ideal_scores = sorted(relevance_scores, reverse=True)
    idcg = sum(score / np.log2(i + 2) for i, score in enumerate(ideal_scores))
    
    # 计算 NDCG
    ndcg = dcg / idcg if idcg > 0 else 0
    
    ndcg_gauge.labels(retrieval_method=retrieval_method, k=k).set(ndcg)
    return ndcg
```

---

## 6. 指标采集方案

### 6.1 Prometheus 采集

**配置示例**：
```yaml
global:
  scrape_interval: 15s
  evaluation_interval: 15s

scrape_configs:
  - job_name: 'jarvis-api'
    scrape_interval: 15s
    metrics_path: '/metrics'
    static_configs:
      - targets: ['api:8000']
  
  - job_name: 'jarvis-worker'
    scrape_interval: 15s
    metrics_path: '/metrics'
    static_configs:
      - targets: ['worker:8001']
```

### 6.2 CloudWatch 采集（AWS）

**配置示例**：
```python
import boto3

cloudwatch = boto3.client('cloudwatch')

def put_metric(metric_name: str, value: float, unit: str = 'Count', dimensions: dict = None):
    """推送指标到 CloudWatch"""
    cloudwatch.put_metric_data(
        Namespace='Jarvis',
        MetricData=[
            {
                'MetricName': metric_name,
                'Value': value,
                'Unit': unit,
                'Dimensions': [
                    {'Name': k, 'Value': v}
                    for k, v in (dimensions or {}).items()
                ]
            }
        ]
    )
```

---

## 7. 告警规则

### 7.1 性能告警

**Prometheus 告警规则**：
```yaml
groups:
  - name: performance_alerts
    rules:
      - alert: HighLatency
        expr: histogram_quantile(0.95, http_request_duration_seconds_bucket) > 2
        for: 5m
        annotations:
          summary: "High latency detected"
          description: "P95 latency is {{ $value }}s"
      
      - alert: HighErrorRate
        expr: rate(http_errors_total[5m]) / rate(http_requests_total[5m]) > 0.01
        for: 5m
        annotations:
          summary: "High error rate detected"
          description: "Error rate is {{ $value }}%"
```

### 7.2 业务告警

**告警规则**：
```yaml
      - alert: LowCacheHitRate
        expr: cache_hit_rate < 0.3
        for: 10m
        annotations:
          summary: "Low cache hit rate"
          description: "Cache hit rate is {{ $value }}%"
      
      - alert: LowRetrievalHitRate
        expr: retrieval_hit_rate < 0.7
        for: 10m
        annotations:
          summary: "Low retrieval hit rate"
          description: "Retrieval hit rate is {{ $value }}%"
```

### 7.3 成本告警

**告警规则**：
```yaml
      - alert: HighTokenCost
        expr: token_cost_total > 1000
        for: 1h
        annotations:
          summary: "High token cost"
          description: "Token cost is ${{ $value }}"
      
      - alert: BudgetExceeded
        expr: token_cost_total / token_budget > 0.8
        for: 1h
        annotations:
          summary: "Budget warning"
          description: "Token cost is {{ $value }}% of budget"
```

---

## 8. 指标看板

### 8.1 Grafana 看板

**看板配置示例**：
```json
{
  "dashboard": {
    "title": "Jarvis Platform Metrics",
    "panels": [
      {
        "title": "QPS",
        "targets": [
          {
            "expr": "rate(http_requests_total[5m])",
            "legendFormat": "{{endpoint}}"
          }
        ]
      },
      {
        "title": "P95 Latency",
        "targets": [
          {
            "expr": "histogram_quantile(0.95, http_request_duration_seconds_bucket)",
            "legendFormat": "{{endpoint}}"
          }
        ]
      },
      {
        "title": "Error Rate",
        "targets": [
          {
            "expr": "rate(http_errors_total[5m]) / rate(http_requests_total[5m])",
            "legendFormat": "{{endpoint}}"
          }
        ]
      }
    ]
  }
}
```

---

## 9. 总结

本文档描述了 Jarvis 企业级 AI 平台的完整指标体系：

1. **性能指标**：QPS、延迟（P50/P95/P99）、SLA（可用性、成功率、错误率）
2. **业务指标**：命中率（缓存、检索、Rerank）、错误率（4xx、5xx、超时）
3. **成本指标**：Token 成本、资源成本（计算、存储、网络）
4. **质量指标**：回答质量（相关性、准确性、完整性）、检索质量（召回率、精确率、NDCG）

这些指标为系统监控、告警、优化提供了全面的数据支撑，确保系统的稳定运行和持续优化。

---

## 附录

### A. 指标定义表

详见指标定义文档

### B. 告警规则配置

详见告警配置文档

### C. Grafana 看板模板

详见看板模板文档
